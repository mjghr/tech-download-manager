package manager

import (
	"fmt"
	"log"
	"net/url"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/mjghr/tech-download-manager/client"
	"github.com/mjghr/tech-download-manager/controller"
	"github.com/mjghr/tech-download-manager/util"
)

type DownloadManager struct{}

func (d *DownloadManager) DownloadQueue(queue *controller.QueueController) {
	log.Printf("Initializing download queue %s with %d controllers and speed limit %d bytes/s", queue.QueueID, len(queue.DownloadControllers), queue.SpeedLimit)

	// Apply queue speed limit to each download controller
	for i, dc := range queue.DownloadControllers {
		if queue.SpeedLimit != 0 {
			log.Printf("Setting speed limit for download controller %d in queue %s to %d bytes/s from queue", i, queue.QueueID, queue.SpeedLimit)
			dc.SpeedLimit = queue.SpeedLimit
		} else {
			log.Printf("Keeping existing speed limit %d bytes/s for download controller %d in queue %s", dc.SpeedLimit, i, queue.QueueID)
		}
	}

	var wg sync.WaitGroup
	sem := make(chan struct{}, queue.ConcurrenDownloadtLimit) // Limit concurrent downloads
	log.Printf("Starting download queue %s with %d concurrent download limit", queue.QueueID, queue.ConcurrenDownloadtLimit)

	for i := range queue.DownloadControllers {
		wg.Add(1)
		sem <- struct{}{}
		go func(dc *controller.DownloadController, idx int) {
			defer wg.Done()
			defer func() { <-sem }()

			log.Printf("Starting goroutine for download controller %d: %s", idx, dc.FileName)
			startTime := time.Now()
			err := d.StartDownload(dc)
			if err != nil {
				log.Printf("Download failed for %s: %v", dc.FileName, err)
				dc.Status = controller.FAILED
			} else {
				dc.Status = controller.COMPLETED
			}
			endTime := time.Now()
			log.Printf("Download completed for %s | Duration: %v | Status: %v", dc.FileName, endTime.Sub(startTime), dc.Status)
		}(queue.DownloadControllers[i], i)
	}
	wg.Wait()

	log.Printf("All downloads in queue %s completed", queue.QueueID)
}

func (d *DownloadManager) StartDownload(downloadController *controller.DownloadController) error {
	log.Printf("Preparing to start download for URL: %s", downloadController.Url)
	httpRequestSender := client.NewHTTPClient()
	reqMethod := "HEAD"
	url := downloadController.Url
	headers := map[string]string{
		"User-Agent": "tech-idm",
	}

	log.Printf("Sending HEAD request to determine file details for %s", url)
	response, err := httpRequestSender.SendRequest(reqMethod, url, headers)
	if err != nil {
		log.Printf("Failed to send HEAD request for %s: %v", url, err)
		return fmt.Errorf("failed to send HEAD request: %w", err)
	}
	defer response.Body.Close()

	contentLength := response.Header.Get("Content-Length")
	log.Printf("Received Content-Length: %s for %s", contentLength, url)
	contentLengthInBytes, err := strconv.Atoi(contentLength)
	if err != nil || contentLengthInBytes <= 0 {
		log.Printf("Invalid or empty Content-Length for %s: %v", url, err)
		return fmt.Errorf("invalid Content-Length '%s': %w", contentLength, err)
	}
	log.Printf("Parsed Content-Length: %d bytes for %s", contentLengthInBytes, url)

	workers, chunkSize := util.CalculateOptimalWorkersAndChunkSize(contentLengthInBytes)
	chunks := downloadController.SplitIntoChunks(workers, chunkSize)
	log.Printf("Calculated %d workers with chunk size %d bytes for %s", workers, chunkSize, url)

	fileName, err := util.ExtractFileName(url)
	if err != nil {
		log.Printf("Failed to extract filename from %s: %v", url, err)
		return fmt.Errorf("failed to extract filename: %w", err)
	}
	log.Printf("Extracted filename: %s", fileName)

	// Initialize download controller fields
	downloadController.TotalSize = contentLengthInBytes
	downloadController.HttpClient = httpRequestSender
	downloadController.Chunks = chunks
	downloadController.FileName = fileName
	downloadController.Status = controller.ONGOING
	log.Printf("Initialized download controller for %s with %d chunks and speed limit %d bytes/s", fileName, workers, downloadController.SpeedLimit)

	log.Printf("Generated byte ranges for %d chunks for %s", len(chunks), fileName)

	tmpPath := util.GiveDefaultTempPath()
	downPath := util.GiveDefaultSavePath()
	log.Printf("Using temp path: %s and download path: %s", tmpPath, downPath)

	// Create directories if they don't exist
	if err := os.MkdirAll(tmpPath, 0755); err != nil {
		log.Printf("Failed to create temp directory %s: %v", tmpPath, err)
		return fmt.Errorf("failed to create temp directory %s: %w", tmpPath, err)
	}
	if err := os.MkdirAll(downPath, 0755); err != nil {
		log.Printf("Failed to create download directory %s: %v", downPath, err)
		return fmt.Errorf("failed to create download directory %s: %w", downPath, err)
	}
	log.Printf("Successfully ensured directories exist: %s and %s", tmpPath, downPath)

	fmt.Printf("Started downloading %s\n", fileName)
	var wg sync.WaitGroup
	for idx, byteChunk := range chunks {
		wg.Add(1)
		go func(idx int, byteChunk [2]int) {
			defer wg.Done()
			log.Printf("Starting download of chunk %d for %s (bytes %d-%d)", idx, fileName, byteChunk[0], byteChunk[1])
			err := downloadController.Download(idx, byteChunk, tmpPath)
			if err != nil {
				log.Printf("Chunk %d failed: %v, retrying...", idx, err)
				retryErr := downloadController.Retry(idx, byteChunk, tmpPath, 10)
				if retryErr != nil {
					log.Printf("Chunk %d failed after retries: %v", idx, retryErr)
					downloadController.SetStatus(controller.FAILED)
				}
			}
		}(idx, byteChunk)
	}
	wg.Wait()

	if downloadController.Status == controller.FAILED {
		return fmt.Errorf("one or more chunks failed to download for %s", fileName)
	}

	fmt.Printf("Done downloading, now merging and removing temp files for %s\n", fileName)
	log.Printf("Merging downloads for %s from %s to %s", fileName, tmpPath, downPath)
	err = downloadController.MergeDownloads(tmpPath, downPath)
	if err != nil {
		log.Printf("Failed to merge downloads for %s: %v", fileName, err)
		return fmt.Errorf("failed to merge downloads: %w", err)
	}

	log.Printf("Cleaning up temporary files for %s in %s", fileName, tmpPath)
	err = downloadController.CleanupTmpFiles(tmpPath)
	if err != nil {
		log.Printf("Failed to clean up temporary files for %s: %v", fileName, err)
		return fmt.Errorf("failed to clean up temporary files: %w", err)
	}

	log.Printf("File successfully generated: %s in %s", fileName, downPath)
	return nil
}

func (d *DownloadManager) NewDownloadController(urlPtr *url.URL) *controller.DownloadController {
	log.Printf("Creating new download controller for URL: %s", urlPtr.String())

	// Initialize HTTP client early to use for HEAD request
	httpClient := client.NewHTTPClient()

	// Get file details with HEAD request
	resp, err := httpClient.SendRequest("HEAD", urlPtr.String(), map[string]string{
		"User-Agent": "tech-idm",
	})
	if err != nil {
		log.Printf("Warning: Failed to get file size: %v", err)
		return &controller.DownloadController{
			Status: controller.FAILED,
			Url:    urlPtr.String(),
			ID:     fmt.Sprintf("dc-%d", time.Now().UnixNano()),
		}
	}
	defer resp.Body.Close()

	// Parse Content-Length
	contentLength := resp.Header.Get("Content-Length")
	totalSize, err := strconv.Atoi(contentLength)
	if err != nil || totalSize <= 0 {
		log.Printf("Warning: Invalid Content-Length '%s': %v", contentLength, err)
		return &controller.DownloadController{
			Status: controller.FAILED,
			Url:    urlPtr.String(),
			ID:     fmt.Sprintf("dc-%d", time.Now().UnixNano()),
		}
	}

	// Get speed limit from environment
	speedLimitStr := os.Getenv("SPEED_LIMIT_KB")
	speedLimit, err := strconv.Atoi(speedLimitStr)
	if err != nil {
		log.Printf("Invalid SPEED_LIMIT_KB value '%s', defaulting to 0: %v", speedLimitStr, err)
		speedLimit = 0
	} else {
		speedLimit = speedLimit * 1024 // Convert KB/s to bytes/s
	}

	// Extract filename from URL
	fileName, err := util.ExtractFileName(urlPtr.String())
	if err != nil {
		log.Printf("Warning: Failed to extract filename: %v", err)
		fileName = fmt.Sprintf("download-%d", time.Now().UnixNano())
	}

	downloadController := &controller.DownloadController{
		ID:         fmt.Sprintf("dc-%d", time.Now().UnixNano()),
		Url:        urlPtr.String(),
		Status:     controller.NOT_STARTED,
		FileName:   fileName,
		TotalSize:  totalSize,
		HttpClient: httpClient,
		SpeedLimit: speedLimit,
		Mutex:      sync.Mutex{},
		ResumeChan: make(chan bool),
		PauseChan:  make(chan bool),
	}

	// Calculate optimal chunks
	workers, chunkSize := util.CalculateOptimalWorkersAndChunkSize(totalSize)
	downloadController.Chunks = downloadController.SplitIntoChunks(workers, chunkSize)
	downloadController.CompletedBytes = make([]int, len(downloadController.Chunks))

	log.Printf("Created download controller %s for file %s: size=%d bytes, chunks=%d, speed_limit=%d bytes/s",
		downloadController.ID,
		downloadController.FileName,
		downloadController.TotalSize,
		downloadController.Chunks,
		downloadController.SpeedLimit,
	)

	return downloadController
}
